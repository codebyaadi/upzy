// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AuthType string

const (
	AuthTypeNone   AuthType = "none"
	AuthTypeBasic  AuthType = "basic"
	AuthTypeBearer AuthType = "bearer"
	AuthTypeApiKey AuthType = "api_key"
	AuthTypeDigest AuthType = "digest"
)

func (e *AuthType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthType(s)
	case string:
		*e = AuthType(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthType: %T", src)
	}
	return nil
}

type NullAuthType struct {
	AuthType AuthType `json:"auth_type"`
	Valid    bool     `json:"valid"` // Valid is true if AuthType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthType) Scan(value interface{}) error {
	if value == nil {
		ns.AuthType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthType), nil
}

type HttpMethod string

const (
	HttpMethodGET     HttpMethod = "GET"
	HttpMethodPOST    HttpMethod = "POST"
	HttpMethodPUT     HttpMethod = "PUT"
	HttpMethodDELETE  HttpMethod = "DELETE"
	HttpMethodPATCH   HttpMethod = "PATCH"
	HttpMethodHEAD    HttpMethod = "HEAD"
	HttpMethodOPTIONS HttpMethod = "OPTIONS"
)

func (e *HttpMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = HttpMethod(s)
	case string:
		*e = HttpMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for HttpMethod: %T", src)
	}
	return nil
}

type NullHttpMethod struct {
	HttpMethod HttpMethod `json:"http_method"`
	Valid      bool       `json:"valid"` // Valid is true if HttpMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullHttpMethod) Scan(value interface{}) error {
	if value == nil {
		ns.HttpMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.HttpMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullHttpMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.HttpMethod), nil
}

type MonitorType string

const (
	MonitorTypeHttp       MonitorType = "http"
	MonitorTypeHttps      MonitorType = "https"
	MonitorTypePing       MonitorType = "ping"
	MonitorTypeTcp        MonitorType = "tcp"
	MonitorTypeDns        MonitorType = "dns"
	MonitorTypeSsl        MonitorType = "ssl"
	MonitorTypeSmtp       MonitorType = "smtp"
	MonitorTypePop3       MonitorType = "pop3"
	MonitorTypeImap       MonitorType = "imap"
	MonitorTypePlaywright MonitorType = "playwright"
	MonitorTypeHeartbeat  MonitorType = "heartbeat"
)

func (e *MonitorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MonitorType(s)
	case string:
		*e = MonitorType(s)
	default:
		return fmt.Errorf("unsupported scan type for MonitorType: %T", src)
	}
	return nil
}

type NullMonitorType struct {
	MonitorType MonitorType `json:"monitor_type"`
	Valid       bool        `json:"valid"` // Valid is true if MonitorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMonitorType) Scan(value interface{}) error {
	if value == nil {
		ns.MonitorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MonitorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMonitorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MonitorType), nil
}

type Account struct {
	ID                    string           `json:"id"`
	AccountID             string           `json:"account_id"`
	ProviderID            string           `json:"provider_id"`
	UserID                string           `json:"user_id"`
	AccessToken           pgtype.Text      `json:"access_token"`
	RefreshToken          pgtype.Text      `json:"refresh_token"`
	IDToken               pgtype.Text      `json:"id_token"`
	AccessTokenExpiresAt  pgtype.Timestamp `json:"access_token_expires_at"`
	RefreshTokenExpiresAt pgtype.Timestamp `json:"refresh_token_expires_at"`
	Scope                 pgtype.Text      `json:"scope"`
	Password              pgtype.Text      `json:"password"`
	CreatedAt             pgtype.Timestamp `json:"created_at"`
	UpdatedAt             pgtype.Timestamp `json:"updated_at"`
}

type Check struct {
	Timestamp      pgtype.Timestamptz `json:"timestamp"`
	MonitorID      string             `json:"monitor_id"`
	TraceID        string             `json:"trace_id"`
	RequestID      string             `json:"request_id"`
	ProbeRegion    string             `json:"probe_region"`
	IsSuccess      bool               `json:"is_success"`
	StatusCode     pgtype.Int4        `json:"status_code"`
	LatencyTotalMs int32              `json:"latency_total_ms"`
	ErrorMessage   pgtype.Text        `json:"error_message"`
	Timings        []byte             `json:"timings"`
}

type Invitation struct {
	ID             string           `json:"id"`
	OrganizationID string           `json:"organization_id"`
	Email          string           `json:"email"`
	Role           pgtype.Text      `json:"role"`
	TeamID         pgtype.Text      `json:"team_id"`
	Status         string           `json:"status"`
	ExpiresAt      pgtype.Timestamp `json:"expires_at"`
	InviterID      string           `json:"inviter_id"`
}

type Member struct {
	ID             string           `json:"id"`
	OrganizationID string           `json:"organization_id"`
	UserID         string           `json:"user_id"`
	Role           string           `json:"role"`
	TeamID         pgtype.Text      `json:"team_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
}

type Monitor struct {
	ID                   string           `json:"id"`
	CreatedByID          string           `json:"created_by_id"`
	OrganizationID       string           `json:"organization_id"`
	Name                 string           `json:"name"`
	Slug                 string           `json:"slug"`
	Url                  string           `json:"url"`
	Type                 MonitorType      `json:"type"`
	Interval             int32            `json:"interval"`
	RequestTimeout       int32            `json:"request_timeout"`
	RetryCount           int32            `json:"retry_count"`
	Enabled              bool             `json:"enabled"`
	IsPaused             bool             `json:"is_paused"`
	HttpMethod           NullHttpMethod   `json:"http_method"`
	RequestBody          pgtype.Text      `json:"request_body"`
	RequestHeaders       []byte           `json:"request_headers"`
	ExpectedStatusCodes  []int32          `json:"expected_status_codes"`
	ExpectedResponseTime pgtype.Int4      `json:"expected_response_time"`
	FollowRedirects      bool             `json:"follow_redirects"`
	VerifySsl            bool             `json:"verify_ssl"`
	SslCheckEnabled      bool             `json:"ssl_check_enabled"`
	SslExpiryThreshold   int32            `json:"ssl_expiry_threshold"`
	AuthType             AuthType         `json:"auth_type"`
	AuthUsername         pgtype.Text      `json:"auth_username"`
	AuthPassword         pgtype.Text      `json:"auth_password"`
	AuthToken            pgtype.Text      `json:"auth_token"`
	DnsServer            pgtype.Text      `json:"dns_server"`
	DnsRecordType        pgtype.Text      `json:"dns_record_type"`
	ExpectedIp           pgtype.Text      `json:"expected_ip"`
	PlaywrightScript     pgtype.Text      `json:"playwright_script"`
	HeartbeatGracePeriod pgtype.Int4      `json:"heartbeat_grace_period"`
	Regions              []string         `json:"regions"`
	Tags                 []byte           `json:"tags"`
	LastCheckAt          pgtype.Timestamp `json:"last_check_at"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
}

type MonitorRegion struct {
	ID       string `json:"id"`
	Code     string `json:"code"`
	Name     string `json:"name"`
	Country  string `json:"country"`
	City     string `json:"city"`
	IsActive bool   `json:"is_active"`
}

type Organization struct {
	ID        string           `json:"id"`
	Name      string           `json:"name"`
	Slug      pgtype.Text      `json:"slug"`
	Logo      pgtype.Text      `json:"logo"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	Metadata  pgtype.Text      `json:"metadata"`
}

type Session struct {
	ID                   string           `json:"id"`
	ExpiresAt            pgtype.Timestamp `json:"expires_at"`
	Token                string           `json:"token"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
	IpAddress            pgtype.Text      `json:"ip_address"`
	UserAgent            pgtype.Text      `json:"user_agent"`
	UserID               string           `json:"user_id"`
	ActiveOrganizationID pgtype.Text      `json:"active_organization_id"`
}

type Team struct {
	ID             string           `json:"id"`
	Name           string           `json:"name"`
	OrganizationID string           `json:"organization_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

type Test struct {
	ID        string           `json:"id"`
	Name      string           `json:"name"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type User struct {
	ID            string           `json:"id"`
	Name          string           `json:"name"`
	Email         string           `json:"email"`
	EmailVerified bool             `json:"email_verified"`
	Image         pgtype.Text      `json:"image"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

type Verification struct {
	ID         string           `json:"id"`
	Identifier string           `json:"identifier"`
	Value      string           `json:"value"`
	ExpiresAt  pgtype.Timestamp `json:"expires_at"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
}
